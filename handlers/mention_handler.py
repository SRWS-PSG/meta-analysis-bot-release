"""
Mention„Éè„É≥„Éâ„É©„Éº

„Éú„ÉÉ„Éà„Å∏„ÅÆ„É°„É≥„Ç∑„Éß„É≥„ÇÑ„ÉÄ„Ç§„É¨„ÇØ„Éà„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂá¶ÁêÜ„Åó„Åæ„Åô„ÄÇ
"""
import logging
import re
import threading
import json
from slack_bolt import App

logger = logging.getLogger(__name__)

def _contains_csv_data(text: str) -> bool:
    """„ÉÜ„Ç≠„Çπ„ÉàÂÜÖ„Å´CSV„Éá„Éº„Çø„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ"""
    logger.info(f"CSV detection check for text: {text[:200]}...")  # ÊúÄÂàù„ÅÆ200ÊñáÂ≠ó„Çí„É≠„Ç∞
    
    lines = text.strip().split('\n')
    logger.info(f"Split into {len(lines)} lines")
    
    if len(lines) < 2:
        logger.info("Less than 2 lines, not CSV")
        return False
    
    # „Éï„Ç°„Ç§„É´Âêç„Çâ„Åó„ÅçË°å„ÅØÈô§Â§ñ (.csv „ÅßÁµÇ„Çè„ÇãË°å)
    non_filename_lines = [line for line in lines if not line.strip().endswith('.csv')]
    
    # Ë§áÊï∞Ë°å„ÅÇ„Çä„ÄÅ„Ç´„É≥„ÉûÂå∫Âàá„Çä„ÅÆ„Éá„Éº„Çø„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
    csv_like_lines = 0
    for i, line in enumerate(non_filename_lines):
        line = line.strip()
        if not line:  # Á©∫Ë°å„Çí„Çπ„Ç≠„ÉÉ„Éó
            continue
            
        # „Çà„ÇäÂπÖÂ∫É„ÅÑÂå∫Âàá„ÇäÊñáÂ≠ó„ÇíÊ§úÂá∫
        # Ë§áÊï∞„ÅÆÈÄ£Á∂ö„Çπ„Éö„Éº„Çπ„ÇíÂå∫Âàá„ÇäÊñáÂ≠ó„Å®„Åó„Å¶Ê§úÂá∫
        has_separator = (',' in line or 
                        '\t' in line or 
                        re.search(r'\s{2,}', line) or  # 2„Å§‰ª•‰∏ä„ÅÆÈÄ£Á∂ö„Çπ„Éö„Éº„Çπ
                        re.search(r'\s+\d+\s+', line))  # Êï∞Â≠ó„ÇíÂõ≤„ÇÄ„Çπ„Éö„Éº„Çπ
        
        if has_separator:
            # ÊúÄ‰Ωé„Åß„ÇÇ2„Å§„ÅÆÂàó„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            if '\t' in line:
                parts = line.split('\t')
            elif ',' in line:
                parts = line.split(',')
            else:
                # Ë§áÊï∞„Çπ„Éö„Éº„Çπ„ÅßÂàÜÂâ≤
                parts = re.split(r'\s{2,}', line)
                if len(parts) == 1:  # 2„Å§‰ª•‰∏ä„ÅÆ„Çπ„Éö„Éº„Çπ„ÅßÂàÜÂâ≤„Åß„Åç„Å™„ÅÑÂ†¥Âêà„ÄÅÂçò‰∏Ä„Çπ„Éö„Éº„Çπ„ÇÇË©¶„Åô
                    parts = line.split()
            
            parts = [p.strip() for p in parts if p.strip()]  # Á©∫Ë¶ÅÁ¥†„ÇíÈô§Âéª
            
            if len(parts) >= 2:
                csv_like_lines += 1
                logger.info(f"Line {i+1} has {len(parts)} parts: {parts[:3]}...")  # ÊúÄÂàù„ÅÆ3Ë¶ÅÁ¥†„Çí„É≠„Ç∞
    
    threshold = max(2, len(non_filename_lines) * 0.5)
    is_csv = csv_like_lines >= threshold
    logger.info(f"CSV-like lines: {csv_like_lines}, threshold: {threshold}, is_csv: {is_csv}")
    
    return is_csv

def register_mention_handlers(app: App):
    """„É°„É≥„Ç∑„Éß„É≥Èñ¢ÈÄ£„ÅÆ„Éè„É≥„Éâ„É©„Éº„ÇíÁôªÈå≤"""
    
    @app.event("app_mention")
    def handle_app_mention(body, event, client, logger):
        """„Éú„ÉÉ„Éà„Åå„É°„É≥„Ç∑„Éß„É≥„Åï„Çå„ÅüÊôÇ„ÅÆÂá¶ÁêÜ"""
        try:
            logger.info("=== APP MENTION EVENT RECEIVED ===")
            logger.info(f"Event timestamp: {event.get('ts')}")
            logger.info(f"Event type: {event.get('type')}")
            logger.info(f"Channel: {event.get('channel')}")
            logger.info(f"User: {event.get('user')}")
            
            # Log the full event in DEBUG mode
            logger.debug(f"Full event object: {json.dumps(event, ensure_ascii=False, indent=2)}")
            
            # Check if there are blocks, attachments, or files
            blocks = event.get("blocks", [])
            attachments = event.get("attachments", [])
            files = event.get("files", [])
            logger.info(f"Event has {len(blocks)} blocks, {len(attachments)} attachments, and {len(files)} files")
            
            # Log the full body for debugging
            logger.info(f"Full body keys: {list(body.keys()) if body else 'No body'}")
            logger.info(f"Full event keys: {list(event.keys())}")
            if blocks:
                logger.info(f"First block: {blocks[0] if blocks else 'No blocks'}")
                # Log all blocks for debugging
                for i, block in enumerate(blocks):
                    logger.info(f"Block {i}: type={block.get('type')}, keys={list(block.keys())}")
                    if block.get('type') == 'rich_text':
                        elements = block.get('elements', [])
                        for j, elem in enumerate(elements):
                            logger.info(f"  Element {j}: type={elem.get('type')}")
            
            # Check for files
            if files:
                logger.info(f"Files found: {files}")
            
            channel_id = event["channel"]
            user_id = event["user"]
            text = event.get("text", "")
            thread_ts = event.get("thread_ts", event["ts"])
            
            # „É°„É≥„Ç∑„Éß„É≥„ÉÜ„Ç≠„Çπ„Éà„Åã„Çâ„Éú„ÉÉ„ÉàID„ÇíÈô§Âéª
            bot_user_id = client.auth_test()["user_id"]
            clean_text = text.replace(f"<@{bot_user_id}>", "").strip()
            
            # If there are code blocks in the message, extract the text from them
            if blocks:
                code_block_text = ""
                for i, block in enumerate(blocks):
                    logger.debug(f"Processing block {i}: type={block.get('type')}")
                    if block.get("type") == "rich_text":
                        for j, element in enumerate(block.get("elements", [])):
                            logger.debug(f"  Processing element {j}: type={element.get('type')}")
                            # Check for both preformatted blocks and sections
                            if element.get("type") == "rich_text_preformatted":
                                # This is a code block
                                logger.info(f"Found rich_text_preformatted block at block[{i}].element[{j}]")
                                for k, elem in enumerate(element.get("elements", [])):
                                    if elem.get("type") == "text":
                                        text_content = elem.get("text", "")
                                        logger.debug(f"    Text element {k}: {text_content[:50]}...")
                                        code_block_text += text_content
                            elif element.get("type") == "rich_text_section":
                                # Check for inline code or regular text that might contain CSV
                                for k, elem in enumerate(element.get("elements", [])):
                                    if elem.get("type") == "text":
                                        # Skip bot mentions
                                        elem_text = elem.get("text", "")
                                        if not elem_text.startswith(f"<@{bot_user_id}>"):
                                            code_block_text += elem_text
                if code_block_text:
                    logger.info(f"Found code block text: {code_block_text[:100]}...")
                    # Always use code block text if it exists
                    clean_text = code_block_text
                else:
                    logger.info("No code blocks found in rich_text elements")
            
            # Fallback: Check if the original text contains code block markers
            if not clean_text or (not _contains_csv_data(clean_text) and "```" in text):
                logger.info("Checking for code blocks in original text field...")
                # Extract text between ``` markers
                import re
                code_block_matches = re.findall(r'```(?:\w+)?\n?(.*?)```', text, re.DOTALL)
                if code_block_matches:
                    logger.info(f"Found {len(code_block_matches)} code blocks in text field")
                    # Use the first code block
                    potential_csv = code_block_matches[0].strip()
                    if _contains_csv_data(potential_csv):
                        clean_text = potential_csv
                        logger.info(f"Using code block from text field: {clean_text[:100]}...")
            
            logger.info(f"=== App Mention Debug ===")
            logger.info(f"Original text: {repr(text)}")
            logger.info(f"Bot user ID: {bot_user_id}")
            logger.info(f"Clean text: {repr(clean_text)}")
            logger.info(f"Clean text length: {len(clean_text)}")
            logger.info(f"Clean text first 100 chars: {clean_text[:100] if clean_text else 'EMPTY'}")
            
            # Check for CSV files
            csv_files = [f for f in files if f.get("name", "").lower().endswith(".csv")]
            if csv_files:
                # CSV„Éï„Ç°„Ç§„É´„ÅåÊ∑ª‰ªò„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà
                logger.info(f"CSV files found: {[f.get('name') for f in csv_files]}")
                client.chat_postMessage(
                    channel=channel_id,
                    thread_ts=thread_ts,
                    text="üìä CSV„Éï„Ç°„Ç§„É´„ÇíÊ§úÂá∫„Åó„Åæ„Åó„Åü„ÄÇÂàÜÊûê„ÇíÈñãÂßã„Åó„Åæ„Åô..."
                )
                
                # CSVÂá¶ÁêÜ„ÇíÂÆüË°å
                from handlers.csv_handler import process_csv_async
                import asyncio
                
                # Run the async function in a thread to avoid event loop issues
                import threading
                
                def run_async_csv_processing():
                    try:
                        loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(loop)
                        for csv_file in csv_files:
                            loop.run_until_complete(process_csv_async(
                                file_info=csv_file,
                                channel_id=channel_id,
                                user_id=user_id,
                                client=client,
                                logger=logger,
                                thread_ts=thread_ts
                            ))
                        loop.close()
                    except Exception as e:
                        logger.error(f"Error in CSV processing thread: {e}", exc_info=True)
                        # „Ç®„É©„Éº„ÇíSlack„Å´ÈÄöÁü•
                        try:
                            client.chat_postMessage(
                                channel=channel_id,
                                thread_ts=thread_ts,
                                text=f"‚ùå CSVÂá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {str(e)}"
                            )
                        except Exception as notify_error:
                            logger.error(f"Failed to notify error: {notify_error}")
                
                thread = threading.Thread(target=run_async_csv_processing)
                thread.start()
                return
            
            if not clean_text:
                # „É°„É≥„Ç∑„Éß„É≥„ÅÆ„Åø„ÅÆÂ†¥Âêà„ÅØ„Éò„É´„Éó„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫
                help_text = (
                    "üëã „Åì„Çì„Å´„Å°„ÅØÔºÅ„É°„ÇøËß£Êûê„Éú„ÉÉ„Éà„Åß„Åô„ÄÇ\n\n"
                    "‰Ωø„ÅÑÊñπ:\n"
                    "1. CSV„Éï„Ç°„Ç§„É´„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ\n"
                    "2. „Éú„ÉÉ„Éà„ÅåËá™Âãï„Åß„É°„ÇøËß£Êûê„Å´ÈÅ©„Åó„Åü„Éá„Éº„Çø„Åã„ÉÅ„Çß„ÉÉ„ÇØ„Åó„Åæ„Åô\n"
                    "3. ÈÅ©„Åó„Å¶„ÅÑ„Çå„Å∞Ëß£Êûê„Éë„É©„É°„Éº„Çø„ÇíÂØæË©±„ÅßË®≠ÂÆö„Åó„ÄÅ\n"
                    "4. Ëß£Êûê„ÇíÂÆüË°å„Åó„Å¶„É¨„Éù„Éº„Éà„ÇíËøîÂç¥„Åó„Åæ„Åô\n\n"
                    "„ÅäÂõ∞„Çä„ÅÆÂ†¥Âêà„ÅØ„ÄÅCSV„Éï„Ç°„Ç§„É´„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑÔºÅ"
                )
                
                client.chat_postMessage(
                    channel=channel_id,
                    thread_ts=thread_ts,
                    text=help_text
                )
            else:
                # CSV„Éá„Éº„Çø„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                logger.info(f"Checking for CSV data in clean_text...")
                contains_csv = _contains_csv_data(clean_text)
                logger.info(f"CSV detection result: {contains_csv}")
                
                if contains_csv:
                    # CSV„Éá„Éº„Çø„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÂá¶ÁêÜ„Åô„Çã
                    client.chat_postMessage(
                        channel=channel_id,
                        thread_ts=thread_ts,
                        text="üìä CSV„Éá„Éº„Çø„ÇíÊ§úÂá∫„Åó„Åæ„Åó„Åü„ÄÇÂàÜÊûê„ÇíÈñãÂßã„Åó„Åæ„Åô..."
                    )
                    
                    # CSVÂá¶ÁêÜ„ÇíÂÆüË°å
                    from handlers.csv_handler import process_csv_text_async
                    import asyncio
                    
                    # Run the async function in a thread to avoid event loop issues
                    import threading
                    
                    def run_async_csv_text_processing():
                        try:
                            loop = asyncio.new_event_loop()
                            asyncio.set_event_loop(loop)
                            loop.run_until_complete(process_csv_text_async(
                                csv_text=clean_text,
                                channel_id=channel_id,
                                user_id=user_id,
                                thread_ts=thread_ts,
                                client=client,
                                logger=logger
                            ))
                            loop.close()
                        except Exception as e:
                            logger.error(f"Error in CSV text processing thread: {e}", exc_info=True)
                            # „Ç®„É©„Éº„ÇíSlack„Å´ÈÄöÁü•
                            try:
                                client.chat_postMessage(
                                    channel=channel_id,
                                    thread_ts=thread_ts,
                                    text=f"‚ùå CSV„Éá„Éº„ÇøÂá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {str(e)}"
                                )
                            except Exception as notify_error:
                                logger.error(f"Failed to notify error: {notify_error}")
                    
                    thread = threading.Thread(target=run_async_csv_text_processing)
                    thread.start()
                else:
                    # „Åù„ÅÆ‰ªñ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà
                    response_text = (
                        f"„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂèó‰ø°„Åó„Åæ„Åó„Åü: „Äå{clean_text}„Äç\n\n"
                        "ÁèæÂú®„ÄÅ„Åì„ÅÆ„Éú„ÉÉ„Éà„ÅØCSV„Éï„Ç°„Ç§„É´„ÅÆ„É°„ÇøËß£Êûê„Å´ÁâπÂåñ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ\n"
                        "CSV„Éï„Ç°„Ç§„É´„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åô„Çã„Åã„ÄÅCSV„Éá„Éº„Çø„Çí„ÉÜ„Ç≠„Çπ„Éà„Å®„Åó„Å¶Ë≤º„Çä‰ªò„Åë„Å¶„ÅÑ„Åü„Å†„Åë„Çå„Å∞„ÄÅËß£Êûê„Çí„ÅäÊâã‰ºù„ÅÑ„Åß„Åç„Åæ„ÅôÔºÅ"
                    )
                    
                    client.chat_postMessage(
                        channel=channel_id,
                        thread_ts=thread_ts,
                        text=response_text
                    )
                
        except Exception as e:
            logger.error(f"Error handling app mention: {e}")
            try:
                client.chat_postMessage(
                    channel=event["channel"],
                    thread_ts=event.get("thread_ts", event["ts"]),
                    text="Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„ÄÇ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÂá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ"
                )
            except Exception as reply_error:
                logger.error(f"Error sending error message: {reply_error}")
    
    @app.event("message")
    def handle_direct_message(body, event, client, logger):
        """„ÉÄ„Ç§„É¨„ÇØ„Éà„É°„ÉÉ„Çª„Éº„Ç∏„Å®„Çπ„É¨„ÉÉ„ÉâËøî‰ø°„ÅÆÂá¶ÁêÜ"""
        try:
            # „Éú„ÉÉ„ÉàËá™Ë∫´„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÅØÁÑ°Ë¶ñ
            if event.get("bot_id"):
                return
            
            # „Çπ„É¨„ÉÉ„ÉâÂÜÖ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            is_thread_message = "thread_ts" in event and event.get("ts") != event.get("thread_ts")
            
            # „ÉÅ„É£„É≥„Éç„É´„Çø„Ç§„Éó„ÇíÁ¢∫Ë™ç
            channel_type = event.get("channel_type")
            
            # „Éï„Ç°„Ç§„É´„ÅÆÁ¢∫Ë™ç
            files = event.get("files", [])
            
            # DM „Åæ„Åü„ÅØ „Çπ„É¨„ÉÉ„ÉâÂÜÖ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÂ†¥Âêà„Å´Âá¶ÁêÜ
            if channel_type == "im" or is_thread_message:
                text = event.get("text", "")
                logger.info(f"Message in thread or DM received: {text[:100]}...")
                logger.info(f"Files in message: {len(files)} files")
                
                # CSV„Éï„Ç°„Ç§„É´„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                csv_files = [f for f in files if f.get("name", "").lower().endswith(".csv")]
                if csv_files:
                    # CSV„Éï„Ç°„Ç§„É´„ÅåÊ∑ª‰ªò„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà
                    channel_id = event["channel"]
                    user_id = event["user"]
                    thread_ts = event.get("thread_ts", event["ts"])
                    
                    logger.info(f"CSV files found in thread: {[f.get('name') for f in csv_files]}")
                    client.chat_postMessage(
                        channel=channel_id,
                        thread_ts=thread_ts,
                        text="üìä CSV„Éï„Ç°„Ç§„É´„ÇíÊ§úÂá∫„Åó„Åæ„Åó„Åü„ÄÇÂàÜÊûê„ÇíÈñãÂßã„Åó„Åæ„Åô..."
                    )
                    
                    # CSVÂá¶ÁêÜ„ÇíÂÆüË°å
                    from handlers.csv_handler import process_csv_async
                    import asyncio
                    
                    # Run the async function in a thread to avoid event loop issues
                    import threading
                    
                    def run_async_csv_processing():
                        try:
                            loop = asyncio.new_event_loop()
                            asyncio.set_event_loop(loop)
                            for csv_file in csv_files:
                                loop.run_until_complete(process_csv_async(
                                    file_info=csv_file,
                                    channel_id=channel_id,
                                    user_id=user_id,
                                    client=client,
                                    logger=logger,
                                    thread_ts=thread_ts
                                ))
                            loop.close()
                        except Exception as e:
                            logger.error(f"Error in CSV processing thread (DM): {e}", exc_info=True)
                            # „Ç®„É©„Éº„ÇíSlack„Å´ÈÄöÁü•
                            try:
                                client.chat_postMessage(
                                    channel=channel_id,
                                    thread_ts=thread_ts,
                                    text=f"‚ùå CSVÂá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {str(e)}"
                                )
                            except Exception as notify_error:
                                logger.error(f"Failed to notify error: {notify_error}")
                    
                    thread = threading.Thread(target=run_async_csv_processing)
                    thread.start()
                # CSV„Éá„Éº„Çø„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                elif _contains_csv_data(text):
                    # CSV„Éá„Éº„Çø„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÂá¶ÁêÜ„Åô„Çã
                    channel_id = event["channel"]
                    user_id = event["user"]
                    thread_ts = event.get("thread_ts", event["ts"])
                    
                    client.chat_postMessage(
                        channel=channel_id,
                        thread_ts=thread_ts,
                        text="üìä CSV„Éá„Éº„Çø„ÇíÊ§úÂá∫„Åó„Åæ„Åó„Åü„ÄÇÂàÜÊûê„ÇíÈñãÂßã„Åó„Åæ„Åô..."
                    )
                    
                    # CSVÂá¶ÁêÜ„ÇíÂÆüË°å
                    from handlers.csv_handler import process_csv_text_async
                    import asyncio
                    
                    # Run the async function in a thread to avoid event loop issues
                    import threading
                    
                    def run_async_csv_text_processing():
                        try:
                            loop = asyncio.new_event_loop()
                            asyncio.set_event_loop(loop)
                            loop.run_until_complete(process_csv_text_async(
                                csv_text=text,
                                channel_id=channel_id,
                                user_id=user_id,
                                thread_ts=thread_ts,
                                client=client,
                                logger=logger
                            ))
                            loop.close()
                        except Exception as e:
                            logger.error(f"Error in CSV text processing thread (DM): {e}", exc_info=True)
                            # „Ç®„É©„Éº„ÇíSlack„Å´ÈÄöÁü•
                            try:
                                client.chat_postMessage(
                                    channel=channel_id,
                                    thread_ts=thread_ts,
                                    text=f"‚ùå CSV„Éá„Éº„ÇøÂá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {str(e)}"
                                )
                            except Exception as notify_error:
                                logger.error(f"Failed to notify error: {notify_error}")
                    
                    thread = threading.Thread(target=run_async_csv_text_processing)
                    thread.start()
                elif channel_type == "im":
                    # DM„ÅßCSV„Éá„Éº„Çø„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åø„Éò„É´„Éó„É°„ÉÉ„Çª„Éº„Ç∏
                    help_text = (
                        "üëã „ÉÄ„Ç§„É¨„ÇØ„Éà„É°„ÉÉ„Çª„Éº„Ç∏„ÅÇ„Çä„Åå„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„ÅôÔºÅ\n\n"
                        "„É°„ÇøËß£Êûê„Éú„ÉÉ„Éà„ÅØ‰ª•‰∏ã„ÅÆÊâãÈ†Ü„Åß„ÅîÂà©Áî®„ÅÑ„Åü„Å†„Åë„Åæ„Åô:\n"
                        "1. CSV„Éï„Ç°„Ç§„É´„Çí„Åì„ÅÆ„ÉÅ„É£„ÉÉ„Éà„Å´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ\n"
                        "2. Ëá™Âãï„Åß„Éá„Éº„Çø„ÇíÂàÜÊûê„Åó„Åæ„Åô\n"
                        "3. „É°„ÇøËß£Êûê„ÅÆË®≠ÂÆö„ÇíË°å„ÅÑ„Åæ„Åô\n"
                        "4. Ëß£Êûê„ÇíÂÆüË°å„Åó„Å¶ÁµêÊûú„ÇíË°®Á§∫„Åó„Åæ„Åô\n\n"
                        "„Åæ„Åö„ÅØCSV„Éï„Ç°„Ç§„É´„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑÔºÅ"
                    )
                    
                    client.chat_postMessage(
                        channel=event["channel"],
                        text=help_text
                    )
                
        except Exception as e:
            logger.error(f"Error handling direct message: {e}")